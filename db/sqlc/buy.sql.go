// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: buy.sql

package db

import (
	"context"
)

const countBuy = `-- name: CountBuy :one
SELECT count(*) FROM buy
`

func (q *Queries) CountBuy(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBuy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteBuy = `-- name: DeleteBuy :one
DELETE FROM buy WHERE id = $1 RETURNING id, action_id_buy, profile_id, number_stocks, "limit", created_at
`

func (q *Queries) DeleteBuy(ctx context.Context, id int64) (Buy, error) {
	row := q.db.QueryRowContext(ctx, deleteBuy, id)
	var i Buy
	err := row.Scan(
		&i.ID,
		&i.ActionIDBuy,
		&i.ProfileID,
		&i.NumberStocks,
		&i.Limit,
		&i.CreatedAt,
	)
	return i, err
}

const getBuyByActionId = `-- name: GetBuyByActionId :many
SELECT id, action_id_buy, profile_id, number_stocks, "limit", created_at FROM buy WHERE action_id_buy = $1
`

func (q *Queries) GetBuyByActionId(ctx context.Context, actionIDBuy int64) ([]Buy, error) {
	rows, err := q.db.QueryContext(ctx, getBuyByActionId, actionIDBuy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Buy{}
	for rows.Next() {
		var i Buy
		if err := rows.Scan(
			&i.ID,
			&i.ActionIDBuy,
			&i.ProfileID,
			&i.NumberStocks,
			&i.Limit,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuyById = `-- name: GetBuyById :one
SELECT id, action_id_buy, profile_id, number_stocks, "limit", created_at FROM buy WHERE id = $1
`

func (q *Queries) GetBuyById(ctx context.Context, id int64) (Buy, error) {
	row := q.db.QueryRowContext(ctx, getBuyById, id)
	var i Buy
	err := row.Scan(
		&i.ID,
		&i.ActionIDBuy,
		&i.ProfileID,
		&i.NumberStocks,
		&i.Limit,
		&i.CreatedAt,
	)
	return i, err
}

const getBuyByProfile_id = `-- name: GetBuyByProfile_id :many
SELECT id, action_id_buy, profile_id, number_stocks, "limit", created_at FROM buy WHERE profile_id = $1
`

func (q *Queries) GetBuyByProfile_id(ctx context.Context, profileID int64) ([]Buy, error) {
	rows, err := q.db.QueryContext(ctx, getBuyByProfile_id, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Buy{}
	for rows.Next() {
		var i Buy
		if err := rows.Scan(
			&i.ID,
			&i.ActionIDBuy,
			&i.ProfileID,
			&i.NumberStocks,
			&i.Limit,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBuy = `-- name: ListBuy :many
SELECT id, action_id_buy, profile_id, number_stocks, "limit", created_at FROM buy LIMIT $1 OFFSET $2
`

type ListBuyParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBuy(ctx context.Context, arg ListBuyParams) ([]Buy, error) {
	rows, err := q.db.QueryContext(ctx, listBuy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Buy{}
	for rows.Next() {
		var i Buy
		if err := rows.Scan(
			&i.ID,
			&i.ActionIDBuy,
			&i.ProfileID,
			&i.NumberStocks,
			&i.Limit,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBuyByProfile_id = `-- name: ListBuyByProfile_id :many
SELECT id, action_id_buy, profile_id, number_stocks, "limit", created_at FROM buy WHERE profile_id = $1 LIMIT $2 OFFSET $3
`

type ListBuyByProfile_idParams struct {
	ProfileID int64 `json:"profileID"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListBuyByProfile_id(ctx context.Context, arg ListBuyByProfile_idParams) ([]Buy, error) {
	rows, err := q.db.QueryContext(ctx, listBuyByProfile_id, arg.ProfileID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Buy{}
	for rows.Next() {
		var i Buy
		if err := rows.Scan(
			&i.ID,
			&i.ActionIDBuy,
			&i.ProfileID,
			&i.NumberStocks,
			&i.Limit,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBuy = `-- name: UpdateBuy :one
UPDATE buy SET
  action_id_buy = COALESCE($1, action_id_buy),
  profile_id = COALESCE($2, profile_id),
  number_stocks = COALESCE($3, number_stocks),
  "limit" = COALESCE($4, "limit")
WHERE id = $5
RETURNING id, action_id_buy, profile_id, number_stocks, "limit", created_at
`

type UpdateBuyParams struct {
	ActionIDBuy  int64  `json:"actionIDBuy"`
	ProfileID    int64  `json:"profileID"`
	NumberStocks int32  `json:"numberStocks"`
	Limit        string `json:"limit"`
	ID           int64  `json:"id"`
}

func (q *Queries) UpdateBuy(ctx context.Context, arg UpdateBuyParams) (Buy, error) {
	row := q.db.QueryRowContext(ctx, updateBuy,
		arg.ActionIDBuy,
		arg.ProfileID,
		arg.NumberStocks,
		arg.Limit,
		arg.ID,
	)
	var i Buy
	err := row.Scan(
		&i.ID,
		&i.ActionIDBuy,
		&i.ProfileID,
		&i.NumberStocks,
		&i.Limit,
		&i.CreatedAt,
	)
	return i, err
}
